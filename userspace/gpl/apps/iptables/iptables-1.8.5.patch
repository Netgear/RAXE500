diff -urN orig_iptables-1.8.5/configure iptables-1.8.5/configure
--- orig_iptables-1.8.5/configure	2020-06-03 19:07:27.000000000 +0800
+++ iptables-1.8.5/configure	2020-06-19 10:01:35.521711807 +0800
@@ -822,6 +822,9 @@
 with_kbuild
 with_ksource
 with_xtlibdir
+with_pfxmods
+with_pf4mods
+with_pf6mods
 enable_ipv4
 enable_ipv6
 enable_largefile
@@ -12460,6 +12463,21 @@
   xtlibdir="${libdir}/xtables"
 fi
 
+# Check whether --with-pfxmods was given.
+if test "${with_pfxmods+set}" = set; then :
+  withval=$with_pfxmods; pfxmods="$withval"
+fi
+
+# Check whether --with-pf4mods was given.
+if test "${with_pf4mods+set}" = set; then :
+  withval=$with_pf4mods; pf4mods="$withval"
+fi
+
+# Check whether --with-pf6mods was given.
+if test "${with_pf6mods+set}" = set; then :
+  withval=$with_pf6mods; pf6mods="$withval"
+fi
+
 # Check whether --enable-ipv4 was given.
 if test "${enable_ipv4+set}" = set; then :
   enableval=$enable_ipv4; enable_ipv4="$enableval"
diff -urN orig_iptables-1.8.5/configure.ac iptables-1.8.5/configure.ac
--- orig_iptables-1.8.5/configure.ac	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/configure.ac	2020-06-19 10:01:35.521711807 +0800
@@ -33,6 +33,21 @@
 	[Path where to install Xtables extensions [[LIBEXECDIR/xtables]]]),
 	[xtlibdir="$withval"],
 	[xtlibdir="${libdir}/xtables"])
+AC_ARG_WITH([pfxmods],
+	AS_HELP_STRING([--with-pfxmods=EXTENSIONS],
+ 	[Path where to install Xtables extensions [[LIBEXECDIR/xtables]]]),
+	[pfxmods="$withval"],
+	[pfxmods=""])
+AC_ARG_WITH([pf4mods],
+	AS_HELP_STRING([--with-pf4mods=EXTENSIONS],
+ 	[Path where to install Xtables extensions [[LIBEXECDIR/xtables]]]),
+	[pf4mods="$withval"],
+	[pf4mods=""])
+AC_ARG_WITH([pf6mods],
+	AS_HELP_STRING([--with-pf6mods=EXTENSIONS],
+ 	[Path where to install Xtables extensions [[LIBEXECDIR/xtables]]]),
+	[pf6mods="$withval"],
+	[pf6mods=""])
 AC_ARG_ENABLE([ipv4],
 	AS_HELP_STRING([--disable-ipv4], [Do not build iptables]),
 	[enable_ipv4="$enableval"], [enable_ipv4="yes"])
@@ -82,6 +97,14 @@
 )
 LDFLAGS="$saved_LDFLAGS";
 
+pfx_modules="$pfxmods";
+pf4_modules="$pf4mods";
+pf6_modules="$pf6mods";
+
+AC_SUBST([pfx_modules])
+AC_SUBST([pf4_modules])
+AC_SUBST([pf6_modules])
+
 blacklist_modules=""
 blacklist_x_modules=""
 blacklist_b_modules=""
diff -urN orig_iptables-1.8.5/extensions/GNUmakefile.in iptables-1.8.5/extensions/GNUmakefile.in
--- orig_iptables-1.8.5/extensions/GNUmakefile.in	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/extensions/GNUmakefile.in	2020-06-19 10:01:35.521711807 +0800
@@ -50,6 +50,9 @@
 pfa_build_mod := $(filter-out @blacklist_modules@ @blacklist_a_modules@,${pfa_build_mod})
 pf4_build_mod := $(filter-out @blacklist_modules@ @blacklist_4_modules@,${pf4_build_mod})
 pf6_build_mod := $(filter-out @blacklist_modules@ @blacklist_6_modules@,${pf6_build_mod})
+pfx_build_mod := $(filter @pfx_modules@,${pfx_build_mod})
+pf4_build_mod := $(filter @pf4_modules@,${pf4_build_mod})
+pf6_build_mod := $(filter @pf6_modules@,${pf6_build_mod})
 pfx_objs      := $(patsubst %,libxt_%.o,${pfx_build_mod})
 pfb_objs      := $(patsubst %,libebt_%.o,${pfb_build_mod})
 pfa_objs      := $(patsubst %,libarpt_%.o,${pfa_build_mod})
diff -urN orig_iptables-1.8.5/extensions/libipt_MASQUERADE.c iptables-1.8.5/extensions/libipt_MASQUERADE.c
--- orig_iptables-1.8.5/extensions/libipt_MASQUERADE.c	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/extensions/libipt_MASQUERADE.c	2020-06-19 10:01:35.521711807 +0800
@@ -12,6 +12,7 @@
 	O_TO_PORTS = 0,
 	O_RANDOM,
 	O_RANDOM_FULLY,
+	O_MODE,
 };
 
 static void MASQUERADE_help(void)
@@ -23,13 +24,16 @@
 " --random\n"
 "				Randomize source port.\n"
 " --random-fully\n"
-"				Fully randomize source port.\n");
+"				Fully randomize source port.\n"
+" --mode <fullcone|symmetric>\n"
+"				NAT mode.\n");
 }
 
 static const struct xt_option_entry MASQUERADE_opts[] = {
 	{.name = "to-ports", .id = O_TO_PORTS, .type = XTTYPE_STRING},
 	{.name = "random", .id = O_RANDOM, .type = XTTYPE_NONE},
 	{.name = "random-fully", .id = O_RANDOM_FULLY, .type = XTTYPE_NONE},
+	{.name = "mode", .id = O_MODE, .type = XTTYPE_STRING},
 	XTOPT_TABLEEND,
 };
 
@@ -90,6 +94,9 @@
 	else
 		portok = 0;
 
+	/* Borrow this field as mode value. The default is symmetric */
+	mr->range[0].min_ip = 0;
+
 	xtables_option_parse(cb);
 	switch (cb->entry->id) {
 	case O_TO_PORTS:
@@ -104,6 +111,15 @@
 	case O_RANDOM_FULLY:
 		mr->range[0].flags |=  NF_NAT_RANGE_PROTO_RANDOM_FULLY;
 		break;
+	case O_MODE:
+		if (strcasecmp(cb->arg, "fullcone") == 0)
+			mr->range[0].min_ip = 1;
+		else if (strcasecmp(cb->arg, "symmetric") == 0)
+			mr->range[0].min_ip = 0;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "Unknown mode %s", cb->arg);
+      break;
 	}
 }
 
@@ -126,6 +142,8 @@
 
 	if (r->flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY)
 		printf(" random-fully");
+	if (r->min_ip == 1)
+		printf("mode: fullcone ");
 }
 
 static void
@@ -145,6 +163,9 @@
 
 	if (r->flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY)
 		printf(" --random-fully");
+
+	if (r->min_ip == 1)
+		printf("--mode fullcone ");
 }
 
 static int MASQUERADE_xlate(struct xt_xlate *xl,
diff -urN orig_iptables-1.8.5/extensions/libxt_blog.c iptables-1.8.5/extensions/libxt_blog.c
--- orig_iptables-1.8.5/extensions/libxt_blog.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_blog.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,85 @@
+/* Shared library add-on to iptables to add blog match support. */
+#include <stdbool.h>
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <netinet/in.h>
+#include <xtables.h>
+#include <linux/netfilter/xt_blog.h>
+
+static void blog_match_help(void)
+{
+	printf(
+"blog match options:\n"
+"[!] --tcp-pureack              match when blog TCP Pure ACK is\n"
+"                               detected.\n");
+}
+
+static const struct option blog_match_opts[] = {
+	{.name = "tcp-pureack",      .has_arg = false, .val = '1'},
+	XT_GETOPT_TABLEEND,
+};
+
+static int
+blog_match_parse(int c, char **argv, int invert, unsigned int *flags,
+          const void *entry, struct xt_entry_match **match)
+{
+	struct xt_blog *bloginfo = (struct xt_blog *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		bloginfo->tcp_pure_ack = 1;
+		bloginfo->invert = invert;
+		break;
+	}
+
+	return 1;
+}
+
+static void
+blog_match_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_blog *bloginfo = (struct xt_blog *)match->data;
+
+	printf(" blog");
+	if (bloginfo->tcp_pure_ack)
+		printf(" TCP Pure ACK");
+	if (bloginfo->invert)
+		printf(" not detected");
+	else
+		printf(" detected");
+}
+
+static void
+blog_match_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_blog *bloginfo = (struct xt_blog *)match->data;
+
+	printf(" blog");
+	if (bloginfo->tcp_pure_ack) {
+		if (bloginfo->invert)
+			printf(" !");
+		printf(" --tcp-pureack ");
+	}
+}
+
+static struct xtables_match blog_match = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "blog",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_blog)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_blog)),
+	.help		= blog_match_help,
+	.parse		= blog_match_parse,
+	.print		= blog_match_print,
+	.save		= blog_match_save,
+	.extra_opts	= blog_match_opts,
+};
+
+void
+_init(void)
+{
+	xtables_register_match(&blog_match);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_DC.c iptables-1.8.5/extensions/libxt_DC.c
--- orig_iptables-1.8.5/extensions/libxt_DC.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_DC.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,36 @@
+/*Shared library add-on to iptables to add DC target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+
+/*Function which prints out usage message*/
+static void DC_help(void)
+{
+    printf("DC target v%s takes no options\n", XTABLES_VERSION);
+}
+
+static int DC_parse(int c, char **argv, int invert, unsigned int *flags,
+                                    const void *entry, struct xt_entry_target **target)
+{
+    return 0;
+}
+
+static struct xtables_target dc_target = 
+{
+    .family     = AF_INET,
+    .name      = "DC",
+    .version  = XTABLES_VERSION,
+    .size          = XT_ALIGN(0),
+    .userspacesize = XT_ALIGN(0),
+    .help         = DC_help,
+    .parse      = DC_parse,
+};
+
+void  _init(void)
+{
+    xtables_register_target(&dc_target);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_flowlabel.c iptables-1.8.5/extensions/libxt_flowlabel.c
--- orig_iptables-1.8.5/extensions/libxt_flowlabel.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_flowlabel.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,106 @@
+/*
+ * Shared library add-on to iptables to add IPv6 flowlabel match support
+ *
+ * BRCM, Feb, 1. 2019.
+ */
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <netdb.h>
+#include <stdbool.h>
+#include <xtables.h>
+#include <linux/types.h>
+
+#include "linux/netfilter/xt_flowlabel.h"
+
+enum {
+	O_FLOWLABEL = 1 << 0,
+};
+
+
+static const struct xt_option_entry flowlabel_mt_opts[] = {
+	{.name = "flowlabel", .id = O_FLOWLABEL, .type = XTTYPE_UINT32,
+	 .flags = XTOPT_INVERT | XTOPT_MAND, .max = XT_FLOWLABEL_MAX},
+	XTOPT_TABLEEND,
+};
+
+static void flowlabel_mt_help(void)
+{
+	printf(
+"flowlabel match options:\n"
+"[!] --flowlabel value    Match IPv6 flowlabel field value\n"
+"                         Max value: 0x%05X\n", XT_FLOWLABEL_MAX);
+}
+
+static void flowlabel_mt_parse(struct xt_option_call *cb)
+{
+	struct xt_flowlabel_info *info = cb->data;
+
+	xtables_option_parse(cb);
+	info->flowlabel = cpu_to_be32(cb->val.u32);
+	if (cb->invert)
+		info->invert = true;
+}
+
+static void flowlabel_mt_check(struct xt_fcheck_call *cb)
+{
+	if (cb->xflags == 0)
+		xtables_error(PARAMETER_PROBLEM,
+		      "flowlabel match: Parameter --flowlabel is required");
+}
+
+static int flowlabel_mt_xlate(struct xt_xlate *xl,
+			const struct xt_xlate_mt_params *params)
+{
+	const struct xt_flowlabel_info *info =
+		(const struct xt_flowlabel_info *)params->match->data;
+
+	xt_xlate_add(xl, "flowlabel %s0x%05X", info->invert ? "!= " : "",
+		     be32_to_cpu(info->flowlabel));
+
+	return 1;
+}
+
+static void flowlabel_mt_print(const void *ip, const struct xt_entry_match *match,
+                         int numeric)
+{
+	const struct xt_flowlabel_info *info = (const void *)match->data;
+
+	printf(" flowlabel match ");
+	if (info->invert)
+		printf("!");
+
+	printf("0x%05X", be32_to_cpu(info->flowlabel));
+}
+
+static void flowlabel_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_flowlabel_info *info = (const void *)match->data;
+
+	if (info->invert)
+		printf(" !");
+	printf(" --flowlabel 0x%05X", be32_to_cpu(info->flowlabel));
+}
+
+static struct xtables_match flowlabel_mt_reg = {
+	.family        = NFPROTO_IPV6,
+	.name          = "flowlabel",
+	.version       = XTABLES_VERSION,
+	.size          = XT_ALIGN(sizeof(struct xt_flowlabel_info)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_flowlabel_info)),
+	.help          = flowlabel_mt_help,
+	.print         = flowlabel_mt_print,
+	.save          = flowlabel_mt_save,
+	.x6_parse      = flowlabel_mt_parse,
+	.x6_fcheck     = flowlabel_mt_check,
+	.xlate         = flowlabel_mt_xlate,
+	.x6_options    = flowlabel_mt_opts,
+
+};
+
+void _init(void)
+{
+	xtables_register_match(&flowlabel_mt_reg);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_layer7.c iptables-1.8.5/extensions/libxt_layer7.c
--- orig_iptables-1.8.5/extensions/libxt_layer7.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_layer7.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,375 @@
+/* 
+   Shared library add-on to iptables for layer 7 matching support. 
+  
+   By Matthew Strait <quadong@users.sf.net>, Oct 2003-Aug 2008.
+
+   http://l7-filter.sf.net 
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version
+   2 of the License, or (at your option) any later version.
+   http://www.gnu.org/licenses/gpl.txt
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <dirent.h>
+
+#include <xtables.h>
+#include <linux/netfilter/xt_layer7.h>
+
+#define MAX_FN_LEN 256
+
+static char l7dir[MAX_FN_LEN] = "\0";
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(
+	"layer7 match options:\n"
+	"    --l7dir <directory> : Look for patterns here instead of /etc/l7-protocols/\n"
+	"                          (--l7dir must be specified before --l7proto if used)\n"
+	"[!] --l7proto <name>: Match named protocol using /etc/l7-protocols/.../name.pat\n");
+}
+
+static const struct option opts[] = {
+	{ .name = "l7proto", .has_arg = 1, .val = 'p' },
+	{ .name = "l7dir",   .has_arg = 1, .val = 'd' },
+	{ .name = NULL }
+};
+
+/* reads filename, puts protocol info into layer7_protocol_info, number of protocols to numprotos */
+static int parse_protocol_file(char * filename, const char * protoname, struct xt_layer7_info *info)
+{
+	FILE * f;
+	char * line = NULL;
+	size_t len = 0;
+
+	enum { protocol, pattern, done } datatype = protocol;
+
+	f = fopen(filename, "r");
+
+	if(!f)
+		return 0;
+
+	while(getline(&line, &len, f) != -1)
+	{
+		if(strlen(line) < 2 || line[0] == '#')
+			continue;
+
+		/* strip the pesky newline... */
+		if(line[strlen(line) - 1] == '\n')
+			line[strlen(line) - 1] = '\0';
+
+		if(datatype == protocol)
+		{
+			/* Ignore everything on the line beginning with the 
+			first space or tab . For instance, this allows the 
+			protocol line in http.pat to be "http " (or 
+			"http I am so cool") instead of just "http". */
+			if(strchr(line, ' ')){
+				char * space = strchr(line, ' ');
+				space[0] = '\0';
+			}
+			if(strchr(line, '\t')){
+				char * space = strchr(line, '\t');
+				space[0] = '\0';
+			}
+
+			/* sanity check.  First non-comment non-blank 
+			line must be the same as the file name. */
+			if(strcmp(line, protoname))
+				xtables_error(OTHER_PROBLEM, 
+					"Protocol name (%s) doesn't match file name (%s).  Bailing out\n",
+					line, filename);
+
+			if(strlen(line) >= MAX_PROTOCOL_LEN)
+				 xtables_error(PARAMETER_PROBLEM, 
+					"Protocol name in %s too long!", filename);
+			strncpy(info->protocol, line, MAX_PROTOCOL_LEN);
+
+			datatype = pattern; 
+		}
+		else if(datatype == pattern)
+		{
+			if(strlen(line) >= MAX_PATTERN_LEN)
+				 xtables_error(PARAMETER_PROBLEM, "Pattern in %s too long!", filename);
+			strncpy(info->pattern, line, MAX_PATTERN_LEN);
+			
+			datatype = done;			
+			break;
+		}
+		else
+			xtables_error(OTHER_PROBLEM, "Internal error");
+	}
+
+	if(datatype != done)
+		xtables_error(OTHER_PROBLEM, "Failed to get all needed data from %s", filename);
+
+	if(line) free(line);
+	fclose(f);
+
+	return 1;
+}
+
+static int hex2dec(char c)
+{
+        switch (c)
+        {
+                case '0' ... '9':
+                        return c - '0';
+                case 'a' ... 'f':
+                        return c - 'a' + 10;
+                case 'A' ... 'F':
+                        return c - 'A' + 10;
+                default:
+                        xtables_error(OTHER_PROBLEM, "hex2dec: bad value!\n");
+                        return 0;
+        }
+}
+
+/* takes a string with \xHH escapes and returns one with the characters 
+they stand for */
+static char * pre_process(char * s)
+{
+	char * result = malloc(strlen(s) + 1);
+	int sindex = 0, rrindex = 0;
+        while( sindex < strlen(s) )
+        {
+            if( sindex + 3 < strlen(s) &&
+                s[sindex] == '\\' && s[sindex+1] == 'x' && 
+                isxdigit(s[sindex + 2]) && isxdigit(s[sindex + 3]) ) 
+                {
+                        /* carefully remember to call tolower here... */
+                        result[rrindex] = tolower( hex2dec(s[sindex + 2])*16 +
+                                                  hex2dec(s[sindex + 3] ) );
+
+			switch ( result[rrindex] )
+			{
+			case 0x24:
+			case 0x28:
+			case 0x29:
+			case 0x2a:
+			case 0x2b:
+			case 0x2e:
+			case 0x3f:
+			case 0x5b:
+			case 0x5c:
+			case 0x5d:
+			case 0x5e:
+			case 0x7c:
+				fprintf(stderr, 
+					"Warning: layer7 regexp contains a control character, %c, in hex (\\x%c%c).\n"
+					"I recommend that you write this as %c or \\%c, depending on what you meant.\n",
+					result[rrindex], s[sindex + 2], s[sindex + 3], result[rrindex], result[rrindex]);
+				break;
+			case 0x00:
+				fprintf(stderr, 
+					"Warning: null (\\x00) in layer7 regexp.  A null terminates the regexp string!\n");
+				break;
+			default:
+				break;
+			}
+
+
+                        sindex += 3; /* 4 total */
+                }
+                else
+                        result[rrindex] = tolower(s[sindex]);
+
+		sindex++; 
+		rrindex++;
+        }
+	result[rrindex] = '\0';
+
+	return result;
+}
+
+#define MAX_SUBDIRS 128
+static char ** readl7dir(char * dirname)
+{
+        DIR             * scratchdir;
+        struct dirent   ** namelist;
+	char ** subdirs = malloc(MAX_SUBDIRS * sizeof(char *));
+
+        int n, d = 1;
+	subdirs[0] = "";
+
+        n = scandir(dirname, &namelist, 0, alphasort);
+
+	if (n < 0)
+	{
+            perror("scandir");
+	    xtables_error(OTHER_PROBLEM, "Couldn't open %s\n", dirname);
+	}
+        else 
+	{
+            	while(n--) 
+		{
+			char fulldirname[MAX_FN_LEN];
+
+			snprintf(fulldirname, MAX_FN_LEN, "%s/%s", dirname, namelist[n]->d_name);
+
+                	if((scratchdir = opendir(fulldirname)) != NULL)
+			{
+				closedir(scratchdir);
+
+				if(!strcmp(namelist[n]->d_name, ".") || 
+				   !strcmp(namelist[n]->d_name, ".."))
+					/* do nothing */ ;
+				else
+				{
+					subdirs[d] = malloc(strlen(namelist[n]->d_name) + 1);
+					strcpy(subdirs[d], namelist[n]->d_name);
+					d++;
+					if(d >= MAX_SUBDIRS - 1)
+					{
+						fprintf(stderr, 
+						  "Too many subdirectories, skipping the rest!\n");
+						break;
+					}
+				}
+			}
+                	free(namelist[n]);
+            	}
+            	free(namelist);
+        }
+	
+	subdirs[d] = NULL;
+
+	return subdirs;
+}
+
+static void parse_layer7_protocol(const char *s, struct xt_layer7_info *info)
+{
+	char filename[MAX_FN_LEN];
+	char * dir = NULL;
+	char ** subdirs;
+	int n = 0, done = 0;
+
+	if(strlen(l7dir) > 0) dir = l7dir;
+	else                  dir = "/etc/l7-protocols";
+
+	subdirs = readl7dir(dir);
+
+	while(subdirs[n] != NULL)
+	{
+		int c = snprintf(filename, MAX_FN_LEN, "%s/%s/%s.pat", dir, subdirs[n], s);
+
+		if(c > MAX_FN_LEN)
+			xtables_error(OTHER_PROBLEM, 
+				"Filename beginning with %s is too long!\n", filename);
+
+		/* read in the pattern from the file */
+		if(parse_protocol_file(filename, s, info)){
+			done = 1;
+			break;
+		}
+		
+		n++;
+	}
+
+	if(!done)
+		xtables_error(OTHER_PROBLEM, 
+			"Couldn't find a pattern definition file for %s.\n", s);
+
+	/* process \xHH escapes and tolower everything. (our regex lib has no
+	case insensitivity option.) */
+	strncpy(info->pattern, pre_process(info->pattern), MAX_PATTERN_LEN);
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_match **match)
+{
+	struct xt_layer7_info *layer7info = 
+		(struct xt_layer7_info *)(*match)->data;
+
+	switch (c) {
+	case 'p':
+		parse_layer7_protocol(argv[optind-1], layer7info);
+		if (invert)
+			layer7info->invert = 1;  /*from true to 1*/
+		*flags = 1;
+#if 0
+		printf(">>> LAYER7 INFO: proto[%s] pat[%s] invert[%s] pkt[%s]\n",
+			layer7info->protocol,
+			layer7info->pattern,
+			(layer7info->invert?"YES":"NO"),
+			(layer7info->pkt?"YES":"NO"));
+#endif
+		break;
+
+	case 'd':
+		if(strlen(argv[optind-1]) >= MAX_FN_LEN)
+			xtables_error(PARAMETER_PROBLEM, "directory name too long\n");
+
+		strncpy(l7dir, argv[optind-1], MAX_FN_LEN);
+
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --l7proto */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "LAYER7 match: You must specify `--l7proto'");
+}
+
+static void print_protocol(char s[], int invert, int numeric)
+{
+	fputs("l7proto ", stdout);
+	if (invert) fputc('!', stdout);
+	printf("%s ", s);
+}
+
+/* Prints out the matchinfo. */
+static void print(const void *ip,
+      const struct xt_entry_match *match,
+      int numeric)
+{
+	printf("LAYER7 ");
+	print_protocol(((struct xt_layer7_info *)match->data)->protocol,
+		  ((struct xt_layer7_info *)match->data)->invert, numeric);
+}
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const void *ip, const struct xt_entry_match *match)
+{
+        const struct xt_layer7_info *info =
+            (const struct xt_layer7_info*) match->data;
+
+        printf("--l7proto %s%s ", (info->invert)? "! ":"", info->protocol);
+}
+
+static struct xtables_match layer7 = { 
+    .family        = AF_INET,
+    .name          = "layer7",
+    .version       = XTABLES_VERSION,
+    .size          = XT_ALIGN(sizeof(struct xt_layer7_info)),
+    .userspacesize = XT_ALIGN(sizeof(struct xt_layer7_info)),
+    .help          = &help,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&layer7);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_mac_extend.c iptables-1.8.5/extensions/libxt_mac_extend.c
--- orig_iptables-1.8.5/extensions/libxt_mac_extend.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_mac_extend.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,156 @@
+
+/* extend from libxt_mac.c for MAC address extend match operations,
+ * i.e, MAC/mask. 
+ * BRCM, Jan, 31. 2019.
+ */
+
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#if defined(__GLIBC__) && __GLIBC__ == 2
+#include <net/ethernet.h>
+#else
+#include <linux/if_ether.h>
+#endif
+#include <xtables.h>
+#include <linux/netfilter/xt_mac_extend.h>
+
+enum {
+	O_MAC = 0,
+};
+
+static void mac_help(void)
+{
+	printf(
+"mac extend match options:\n"
+"[!] --mac-source-extend[/mask] XX:XX:XX:XX:XX:XX/FF:FF:FF:00:00:00\n"
+"				Match source MAC address/mask\n");
+}
+
+#define s struct xt_mac_info_extend
+static const struct xt_option_entry mac_opts[] = {
+	{.name = "mac-source-extend", .id = O_MAC, .type = XTTYPE_ETHERMAC,
+	 .flags = XTOPT_MAND | XTOPT_INVERT | XTOPT_PUT,
+	 XTOPT_POINTER(s, srcaddr)},
+	XTOPT_TABLEEND,
+};
+#undef s
+
+static int mac_mask(char *mask_in, unsigned char *mask_out)
+{
+	const char *arg = mask_in;
+	unsigned int i;
+	char *end;
+
+	for (i = 0; i < ETH_ALEN; ++i) {
+		mask_out[i] = strtoul(arg, &end, 16);
+		if (((i < (ETH_ALEN - 1)) && (*end != ':')) ||
+			((i == (ETH_ALEN - 1)) && (*end != '\0' )) || 
+			(end - arg > 2))
+			return -1;
+		arg = end + 1;
+	}
+	return 0;
+}
+
+static void mac_parse(struct xt_option_call *cb)
+{
+	struct xt_mac_info_extend *macinfo = cb->data;
+	char *p;
+
+	/* first the mask */
+	if ((p = strrchr(cb->arg, '/')) != NULL) {
+		*p = '\0';
+		if (mac_mask(p + 1, macinfo->msk)) {
+			xtables_error(PARAMETER_PROBLEM,
+				      "Problem with the MAC mask '%s'", p + 1);
+			return;
+		}
+	} else {
+		/* default mask = FF:FF:FF:FF:FF:FF */
+		int i;
+		for (i = 0; i < ETH_ALEN; i++) {
+			macinfo->msk[i] = 0xFF;
+		}
+	}
+    
+	xtables_option_parse(cb);
+	if (cb->invert)
+		macinfo->invert = 1;
+}
+
+static void print_mac(const unsigned char *macaddress)
+{
+	unsigned int i;
+
+	printf(" %02X", macaddress[0]);
+	for (i = 1; i < ETH_ALEN; ++i)
+		printf(":%02X", macaddress[i]);
+}
+
+static void
+mac_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_mac_info_extend *info = (void *)match->data;
+
+	printf(" MAC");
+
+	if (info->invert)
+		printf(" !");
+
+	print_mac(info->srcaddr);
+	printf(" /");
+	print_mac(info->msk);
+}
+
+static void mac_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_mac_info_extend *info = (void *)match->data;
+
+	if (info->invert)
+		printf(" !");
+
+	printf(" --mac-source");
+	print_mac(info->srcaddr);
+}
+
+static void print_mac_xlate(const unsigned char *macaddress,
+			    struct xt_xlate *xl)
+{
+	unsigned int i;
+
+	xt_xlate_add(xl, "%02x", macaddress[0]);
+	for (i = 1; i < ETH_ALEN; ++i)
+		xt_xlate_add(xl, ":%02x", macaddress[i]);
+}
+
+static int mac_xlate(struct xt_xlate *xl,
+		     const struct xt_xlate_mt_params *params)
+{
+	const struct xt_mac_info_extend *info = (void *)params->match->data;
+
+	xt_xlate_add(xl, "ether saddr%s ", info->invert ? " !=" : "");
+	print_mac_xlate(info->srcaddr, xl);
+
+	return 1;
+}
+
+static struct xtables_match mac_match = {
+	.family		= NFPROTO_UNSPEC,
+	.name		= "mac-extend",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct xt_mac_info_extend)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_mac_info_extend)),
+	.help		= mac_help,
+	.x6_parse	= mac_parse,
+	.print		= mac_print,
+	.save		= mac_save,
+	.x6_options	= mac_opts,
+	.xlate		= mac_xlate,
+};
+
+void _init(void)
+{
+	xtables_register_match(&mac_match);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_SKIPLOG.c iptables-1.8.5/extensions/libxt_SKIPLOG.c
--- orig_iptables-1.8.5/extensions/libxt_SKIPLOG.c	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_SKIPLOG.c	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,51 @@
+/* Shared library add-on to iptables to add SKIPLOG target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+
+/* Function which prints out usage message. */
+static void SKIPLOG_help(void)
+{
+	printf(
+"SKIPLOG target v%s takes no options\n",
+XTABLES_VERSION);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+SKIPLOG_parse(int c, char **argv, int invert, unsigned int *flags,
+              const void *entry, struct xt_entry_target **target)
+{
+	return 0;
+}
+
+static struct xtables_target skiplog_target = {
+	.family		= AF_INET,
+	.name		= "SKIPLOG",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(0),
+	.userspacesize	= XT_ALIGN(0),
+	.help		= SKIPLOG_help,
+	.parse		= SKIPLOG_parse,
+};
+
+static struct xtables_target skiplog_target6 = {
+	.family		= AF_INET6,
+	.name		= "SKIPLOG",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(0),
+	.userspacesize	= XT_ALIGN(0),
+	.help		= SKIPLOG_help,
+	.parse		= SKIPLOG_parse,
+};
+
+void _init(void)
+{
+	xtables_register_target(&skiplog_target);
+	xtables_register_target(&skiplog_target6);
+}
diff -urN orig_iptables-1.8.5/extensions/libxt_tcp.c iptables-1.8.5/extensions/libxt_tcp.c
--- orig_iptables-1.8.5/extensions/libxt_tcp.c	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/extensions/libxt_tcp.c	2020-06-19 10:01:35.525711768 +0800
@@ -23,7 +23,9 @@
 "[!] --destination-port port[:port]\n"
 " --dport ...\n"
 "				match destination port(s)\n"
-"[!] --tcp-option number        match if TCP option set\n");
+"[!] --tcp-option number        match if TCP option set\n"
+"[!] --tcp-pureack              match when only ACK flag set and\n"
+"                               payload length is zero\n");
 }
 
 static const struct option tcp_opts[] = {
@@ -34,6 +36,7 @@
 	{.name = "syn",              .has_arg = false, .val = '3'},
 	{.name = "tcp-flags",        .has_arg = true,  .val = '4'},
 	{.name = "tcp-option",       .has_arg = true,  .val = '5'},
+	{.name = "tcp-pureack",      .has_arg = false, .val = '6'},
 	XT_GETOPT_TABLEEND,
 };
 
@@ -168,7 +171,7 @@
 		if (*flags & TCP_FLAGS)
 			xtables_error(PARAMETER_PROBLEM,
 				   "Only one of `--syn' or `--tcp-flags' "
-				   " allowed");
+				   " or --tcp-pureack allowed");
 		parse_tcp_flags(tcpinfo, "SYN,RST,ACK,FIN", "SYN", invert);
 		*flags |= TCP_FLAGS;
 		break;
@@ -177,7 +180,7 @@
 		if (*flags & TCP_FLAGS)
 			xtables_error(PARAMETER_PROBLEM,
 				   "Only one of `--syn' or `--tcp-flags' "
-				   " allowed");
+				   " or --tcp-pureack allowed");
 		if (!argv[optind]
 		    || argv[optind][0] == '-' || argv[optind][0] == '!')
 			xtables_error(PARAMETER_PROBLEM,
@@ -198,6 +201,16 @@
 			tcpinfo->invflags |= XT_TCP_INV_OPTION;
 		*flags |= TCP_OPTION;
 		break;
+
+	case '6':
+		if (*flags & TCP_FLAGS)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Only one of `--syn' or `--tcp-flags' "
+				   " or --tcp-pureack allowed");
+		parse_tcp_flags(tcpinfo, "SYN,RST,ACK,FIN", "ACK", invert);
+		tcpinfo->pure_ack = 1;
+		*flags |= TCP_FLAGS;
+		break;
 	}
 
 	return 1;
@@ -307,6 +320,8 @@
 	print_flags(tcp->flg_mask, tcp->flg_cmp,
 		    tcp->invflags & XT_TCP_INV_FLAGS,
 		    numeric);
+    if (tcp->pure_ack)
+		printf(" pure ACK");
 	if (tcp->invflags & ~XT_TCP_INV_MASK)
 		printf(" Unknown invflags: 0x%X",
 		       tcp->invflags & ~XT_TCP_INV_MASK);
@@ -360,6 +375,12 @@
 		printf(" ");
 		print_tcpf(tcpinfo->flg_cmp);
 	}
+
+	if (tcpinfo->pure_ack) {
+		if (tcpinfo->invflags & XT_TCP_INV_FLAGS)
+			printf(" !");
+		printf(" --tcp-pureack ");
+	}
 }
 
 static const struct tcp_flag_names tcp_flag_names_xlate[] = {
diff -urN orig_iptables-1.8.5/include/linux/netfilter/nf_conntrack_tuple_common.h iptables-1.8.5/include/linux/netfilter/nf_conntrack_tuple_common.h
--- orig_iptables-1.8.5/include/linux/netfilter/nf_conntrack_tuple_common.h	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/nf_conntrack_tuple_common.h	2020-06-19 10:01:35.525711768 +0800
@@ -32,6 +32,11 @@
 	struct {
 		__be16 key;	/* GRE key is 32bit, PPtP only uses 16bit */
 	} gre;
+#ifdef SUPPORT_IPSEC_PASSTHROUGH
+	struct {
+		__be16 spi;
+	} esp;
+#endif
 };
 
 #define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)
diff -urN orig_iptables-1.8.5/include/linux/netfilter/xt_blog.h iptables-1.8.5/include/linux/netfilter/xt_blog.h
--- orig_iptables-1.8.5/include/linux/netfilter/xt_blog.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/xt_blog.h	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,11 @@
+#ifndef _XT_BLOG_H
+#define _XT_BLOG_H
+
+#include <linux/types.h>
+
+struct xt_blog {
+    __u8 tcp_pure_ack;
+    __u8 invert;
+};
+
+#endif /*_XT_BLOG_H*/
diff -urN orig_iptables-1.8.5/include/linux/netfilter/xt_flowlabel.h iptables-1.8.5/include/linux/netfilter/xt_flowlabel.h
--- orig_iptables-1.8.5/include/linux/netfilter/xt_flowlabel.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/xt_flowlabel.h	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,35 @@
+#ifndef _XT_FLOWLABEL_H
+#define _XT_FLOWLABEL_H
+
+/*
+ * Shared library add-on to iptables to add IPv6 flowlabel match support
+ *
+ * BRCM, Feb, 1. 2019.
+ */
+
+#include <byteswap.h>
+
+
+#if defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
+#define be32_to_cpu(x) bswap_32(x)
+#define cpu_to_be32(x) bswap_32(x)
+
+#elif defined(__BIG_ENDIAN) && (__BYTE_ORDER == __BIG_ENDIAN)
+#define be32_to_cpu(x) (x)
+#define cpu_to_be32(x) (x)
+
+#else
+#error "You must define __BYTE_ORDER to be __LITTLE_ENDIAN or __BIG_ENDIAN."
+#endif // defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
+
+
+#define XT_FLOWLABEL_MAX	0x000FFFFF
+
+/* match info */
+struct xt_flowlabel_info {
+	__be32 flowlabel;
+	__u8 invert;
+};
+
+#endif /*_XT_FLOWLABEL_H*/
+
diff -urN orig_iptables-1.8.5/include/linux/netfilter/xt_layer7.h iptables-1.8.5/include/linux/netfilter/xt_layer7.h
--- orig_iptables-1.8.5/include/linux/netfilter/xt_layer7.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/xt_layer7.h	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,19 @@
+#ifndef _XT_LAYER7_H
+#define _XT_LAYER7_H
+
+#if 0
+#define MAX_PATTERN_LEN 8192
+#define MAX_PROTOCOL_LEN 256
+#else
+#define MAX_PATTERN_LEN 256
+#define MAX_PROTOCOL_LEN 64
+#endif
+
+struct xt_layer7_info {
+	char protocol[MAX_PROTOCOL_LEN];
+ 	char pattern[MAX_PATTERN_LEN];
+ 	u_int8_t invert;
+ 	u_int8_t pkt;
+};
+
+#endif /* _XT_LAYER7_H */
diff -urN orig_iptables-1.8.5/include/linux/netfilter/xt_mac_extend.h iptables-1.8.5/include/linux/netfilter/xt_mac_extend.h
--- orig_iptables-1.8.5/include/linux/netfilter/xt_mac_extend.h	1970-01-01 08:00:00.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/xt_mac_extend.h	2020-06-19 10:01:35.525711768 +0800
@@ -0,0 +1,14 @@
+#ifndef _XT_MAC_EXTEND_H
+#define _XT_MAC_EXTEND_H
+
+/* extend from xt_mac.h for MAC address extend match operations,
+ * i.e, MAC/mask. 
+ * BRCM, Jan, 31. 2019.
+ */
+
+struct xt_mac_info_extend {
+    unsigned char srcaddr[ETH_ALEN];
+    unsigned char msk[ETH_ALEN];
+    int invert;
+};
+#endif /*_XT_MAC_EXTEND_H*/
diff -urN orig_iptables-1.8.5/include/linux/netfilter/xt_tcpudp.h iptables-1.8.5/include/linux/netfilter/xt_tcpudp.h
--- orig_iptables-1.8.5/include/linux/netfilter/xt_tcpudp.h	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/include/linux/netfilter/xt_tcpudp.h	2020-06-19 10:01:35.525711768 +0800
@@ -11,6 +11,7 @@
 	__u8 flg_mask;			/* TCP flags mask byte */
 	__u8 flg_cmp;			/* TCP flags compare byte */
 	__u8 invflags;			/* Inverse flags */
+	__u8 pure_ack;			/* Pure ACK packet */
 };
 
 /* Values for "inv" field in struct ipt_tcp. */
diff -urN orig_iptables-1.8.5/iptables/Makefile.am iptables-1.8.5/iptables/Makefile.am
--- orig_iptables-1.8.5/iptables/Makefile.am	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/iptables/Makefile.am	2020-06-19 10:01:35.525711768 +0800
@@ -22,7 +22,7 @@
 xtables_legacy_multi_LDADD   += ../libiptc/libip6tc.la ../extensions/libext6.a
 endif
 xtables_legacy_multi_SOURCES += xshared.c iptables-restore.c iptables-save.c
-xtables_legacy_multi_LDADD   += ../libxtables/libxtables.la -lm
+xtables_legacy_multi_LDADD   += ../libxtables/libxtables.la -lm -ldl
 
 # iptables using nf_tables api
 if ENABLE_NFTABLES
@@ -104,7 +104,6 @@
 
 # Using if..fi avoids an ugly "error (ignored)" message :)
 install-exec-hook:
-	-if test -z "${DESTDIR}"; then /sbin/ldconfig; fi;
 	${INSTALL} -dm0755 "${DESTDIR}${bindir}";
 	for i in ${vx_bin_links}; do ${LN_S} -f "${sbindir}/xtables-legacy-multi" "${DESTDIR}${bindir}/$$i"; done;
 	for i in ${v4_sbin_links}; do ${LN_S} -f xtables-legacy-multi "${DESTDIR}${sbindir}/$$i"; done;
diff -urN orig_iptables-1.8.5/iptables/Makefile.in iptables-1.8.5/iptables/Makefile.in
--- orig_iptables-1.8.5/iptables/Makefile.in	2020-06-03 19:07:28.000000000 +0800
+++ iptables-1.8.5/iptables/Makefile.in	2020-06-19 10:01:35.525711768 +0800
@@ -1550,7 +1550,6 @@
 
 # Using if..fi avoids an ugly "error (ignored)" message :)
 install-exec-hook:
-	-if test -z "${DESTDIR}"; then /sbin/ldconfig; fi;
 	${INSTALL} -dm0755 "${DESTDIR}${bindir}";
 	for i in ${vx_bin_links}; do ${LN_S} -f "${sbindir}/xtables-legacy-multi" "${DESTDIR}${bindir}/$$i"; done;
 	for i in ${v4_sbin_links}; do ${LN_S} -f xtables-legacy-multi "${DESTDIR}${sbindir}/$$i"; done;
diff -urN orig_iptables-1.8.5/libxtables/xtoptions.c iptables-1.8.5/libxtables/xtoptions.c
--- orig_iptables-1.8.5/libxtables/xtoptions.c	2020-06-03 18:32:01.000000000 +0800
+++ iptables-1.8.5/libxtables/xtoptions.c	2020-06-19 10:01:35.525711768 +0800
@@ -545,6 +545,10 @@
 	struct addrinfo *res = NULL, *p;
 	int ret;
 
+   /* brcm */
+   if ((ret = strtol(name, NULL, 0)) > 0)
+      return ret;
+   
 	ret = getaddrinfo(NULL, name, NULL, &res);
 	if (ret != 0)
 		return -1;
