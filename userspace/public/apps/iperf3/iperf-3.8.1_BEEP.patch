diff -Naurp iperf-3.8.1_orig/src/iperf_api.c iperf-3.8.1_beep/src/iperf_api.c
--- iperf-3.8.1_orig/src/iperf_api.c	2020-08-13 16:14:38.097981075 +0800
+++ iperf-3.8.1_beep/src/iperf_api.c	2020-08-13 16:17:17.544980123 +0800
@@ -94,6 +94,12 @@
 #ifdef CONFIG_BCM_SPDTEST
 #include "spdt_api.h"
 #endif
+
+#include <gio/gio.h>
+#include <glib/gprintf.h>
+#include <glib-unix.h>
+#include "beep.h"
+
 /* Forwards. */
 static int send_parameters(struct iperf_test *test);
 static int get_parameters(struct iperf_test *test);
@@ -105,6 +111,43 @@ static int JSON_write(int fd, cJSON *jso
 static void print_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams);
 static cJSON *JSON_read(int fd);
 
+int iperf_send_tcp_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   iperf_size_t bytes_received, 
+                   int stream_retrans);
+
+int iperf_send_udp_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   iperf_size_t bytes_received,
+                   double jitter,
+                   int lost_packets,
+                   int total_packets,
+                   double lost_percent);
+
+int iperf_send_tcp_interval_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   float duration, 
+                   int stream_retrans);
+
+int iperf_send_udp_interval_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   float duration,
+                   double jitter,
+                   int lost_packets,
+                   int total_packets,
+                   double lost_percent);
 
 /*************************** Print usage functions ****************************/
 
@@ -2549,6 +2592,8 @@ iperf_defaults(struct iperf_test *testp)
     testp->on_connect = iperf_on_connect;
     testp->on_test_finish = iperf_on_test_finish;
 
+    testp->dbusConnection = NULL;
+
     TAILQ_INIT(&testp->server_output_list);
 
     return 0;
@@ -3120,6 +3165,7 @@ iperf_print_intermediate(struct iperf_te
                         else
                             iperf_printf(test, report_sum_bw_format, mbuf, start_time, end_time, ubuf, nbuf, test->omitting?report_omitted:"");
                     }
+       iperf_send_tcp_interval_results_dbus(test, -1, start_time, end_time, bytes, irp->interval_duration, retransmits);
                 } else {
                     /* Interval sum, UDP. */
                     if (stream_must_be_sender) {
@@ -3127,6 +3173,8 @@ iperf_print_intermediate(struct iperf_te
                             cJSON_AddItemToObject(json_interval, "sum", iperf_json_printf("start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) total_packets, test->omitting, stream_must_be_sender));
                         else
                             iperf_printf(test, report_sum_bw_udp_sender_format, mbuf, start_time, end_time, ubuf, nbuf, zbuf, total_packets, test->omitting?report_omitted:"");
+      /* Sender */
+      iperf_send_udp_interval_results_dbus(test, -1, start_time, end_time, bytes, irp->interval_duration, 0, 0, total_packets, 0);
                     } else {
                         avg_jitter /= test->num_streams;
                         if (total_packets > 0) {
@@ -3139,6 +3187,8 @@ iperf_print_intermediate(struct iperf_te
                             cJSON_AddItemToObject(json_interval, "sum", iperf_json_printf("start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, test->omitting, stream_must_be_sender));
                         else
                             iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, test->omitting?report_omitted:"");
+      /* Receiver */
+      iperf_send_udp_interval_results_dbus(test, -1, start_time, end_time, bytes, irp->interval_duration, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent);
                     }
                 }
             }
@@ -3404,6 +3454,8 @@ iperf_print_results(struct iperf_test *t
                         if ((sp->outoforder_packets - sp->omitted_outoforder_packets) > 0)
                           iperf_printf(test, report_sum_outoforder, mbuf, start_time, sender_time, (sp->outoforder_packets - sp->omitted_outoforder_packets));
                     }
+       //iperf_send_udp_results_dbus(test, sp->socket, start_time, end_time, bytes_sent, sp->jitter * 1000.0, (sp->cnt_error - sp->omitted_cnt_error), (sp->packet_count - sp->omitted_packet_count), lost_percent);
+       iperf_send_udp_results_dbus(test, sp->socket, start_time, end_time, bytes_sent, bytes_received, sp->jitter * 1000.0, (sp->cnt_error - sp->omitted_cnt_error), (sp->packet_count - sp->omitted_packet_count), lost_percent);
                 }
 
                 if (sp->diskfile_fd >= 0) {
@@ -3448,6 +3500,8 @@ iperf_print_results(struct iperf_test *t
                         else {
                             iperf_printf(test, report_bw_format, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);
                         }
+       /* Summary, TCP. */
+      iperf_send_tcp_results_dbus(test, sp->socket, start_time, end_time, bytes_sent, bytes_received, sp->result->stream_retrans);
                 }
                 else {
                     /*
@@ -3531,6 +3585,7 @@ iperf_print_results(struct iperf_test *t
                     else {
                         iperf_printf(test, report_sum_bw_format, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);
                     }
+      iperf_send_tcp_results_dbus(test, -1, start_time, end_time, total_sent, total_received, total_retransmits);
             } else {
                 /* Summary sum, UDP. */
                 avg_jitter /= test->num_streams;
@@ -3567,6 +3622,8 @@ iperf_print_results(struct iperf_test *t
                         iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, receiver_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, receiver_total_packets, lost_percent, "receiver");
                     }
                 }
+      //iperf_send_udp_results_dbus(test, -1, start_time, end_time, total_sent, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent);
+      iperf_send_udp_results_dbus(test, -1, start_time, end_time, total_sent, total_received, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent);
             }
         }
 
@@ -3762,6 +3819,7 @@ print_interval_results(struct iperf_test
 	    else
 		iperf_printf(test, report_bw_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->omitted?report_omitted:"");
 	}
+   iperf_send_tcp_interval_results_dbus(test, sp->socket, st, et, irp->bytes_transferred, irp->interval_duration, irp->interval_retrans);
     } else {
 	/* Interval, UDP. */
 	if (sp->sender) {
@@ -3769,6 +3827,9 @@ print_interval_results(struct iperf_test
 		cJSON_AddItemToArray(json_interval_streams, iperf_json_printf("socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_packet_count, irp->omitted, sp->sender));
 	    else
 		iperf_printf(test, report_bw_udp_sender_format, sp->socket, mbuf, st, et, ubuf, nbuf, zbuf, irp->interval_packet_count, irp->omitted?report_omitted:"");
+       /* Sender */
+       iperf_send_udp_interval_results_dbus(test, sp->socket, st, et, irp->bytes_transferred, irp->interval_duration, 0, 0, irp->interval_packet_count, 0);
+
 	} else {
 	    if (irp->interval_packet_count > 0) {
 		lost_percent = 100.0 * irp->interval_cnt_error / irp->interval_packet_count;
@@ -3780,6 +3841,8 @@ print_interval_results(struct iperf_test
 		cJSON_AddItemToArray(json_interval_streams, iperf_json_printf("socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (double) irp->jitter * 1000.0, (int64_t) irp->interval_cnt_error, (int64_t) irp->interval_packet_count, (double) lost_percent, irp->omitted, sp->sender));
 	    else
 		iperf_printf(test, report_bw_udp_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent, irp->omitted?report_omitted:"");
+       /* Receiver */
+      iperf_send_udp_interval_results_dbus(test, sp->socket, st, et, irp->bytes_transferred, irp->interval_duration, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent);
 	}
     }
 
@@ -4357,3 +4420,237 @@ iflush(struct iperf_test *test)
 {
     return fflush(test->outfile);
 }
+
+static double unit_atof_ignore_suffix(const char *s)
+{
+   double    n;
+   char      suffix = '\0';
+
+   assert(s != NULL);
+
+   /* scan the number and any suffices */
+	sscanf(s, "%lf%c", &n, &suffix);
+   return n;
+}
+
+int
+iperf_send_tcp_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   iperf_size_t bytes_received, 
+                   int stream_retrans)
+{
+   char bytes_sent_buf[UNIT_LEN];
+   char bytes_received_buf[UNIT_LEN];
+   char sbw_buff[UNIT_LEN];
+   char cbw_buff[UNIT_LEN];
+   double bandwidth;
+   GError *error = NULL;
+   GVariant *resault = NULL;
+
+   // only send interval result for (1) single stream or (2) sum of the multiple streams
+   if (test->num_streams > 1 && streamID != -1)
+   {
+      return 0;
+   }
+   unit_snprintf(bytes_sent_buf, UNIT_LEN, (double) bytes_sent, 'M');
+   bandwidth = (double) bytes_sent / (double) end_time;
+   unit_snprintf(sbw_buff, UNIT_LEN, bandwidth, 'm');
+
+   unit_snprintf(bytes_received_buf, UNIT_LEN, (double) bytes_received, 'M');
+	bandwidth = (double) bytes_received / (double) end_time;
+   unit_snprintf(cbw_buff, UNIT_LEN, bandwidth, 'm');
+   
+   resault = g_variant_new ("(ddddi)",
+                                       unit_atof_ignore_suffix(sbw_buff), 
+                                       unit_atof_ignore_suffix(cbw_buff), 
+                                       unit_atof_ignore_suffix(bytes_sent_buf), 
+                                       unit_atof_ignore_suffix(bytes_received_buf),
+                                       stream_retrans);
+
+   g_dbus_connection_emit_signal((GDBusConnection *)test->dbusConnection,
+                NULL, //maybe we can specify "bbcd" as the destination
+                IPERF_OBJ_PATH,
+                IPERF_INTERFACE,
+                SIGNAL_IPERF_RESULTS,
+                g_variant_new("(iv)", RESAULT_END, resault),
+                &error);
+
+   g_assert_no_error(error);
+   return 0;
+}
+
+int
+iperf_send_tcp_interval_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   float duration, 
+                   int stream_retrans)
+{
+   char bytes_sent_buf[UNIT_LEN];
+   char bw_buff[UNIT_LEN];
+   double bandwidth;
+   GError *error = NULL;
+   GVariant *resault = NULL;
+   int sender_retrans = -1;
+
+   // only send interval result for (1) single stream or (2) sum of the multiple streams
+   if (test->num_streams > 1 && streamID != -1)
+   {
+      return 0;
+   }
+   unit_snprintf(bytes_sent_buf, UNIT_LEN, (double) bytes_sent, 'M');
+   if (duration > 0.0) {
+	   bandwidth = (double) bytes_sent / (double) duration;
+   }
+    else 
+   {
+	   bandwidth = 0.0;
+   }
+   unit_snprintf(bw_buff, UNIT_LEN, bandwidth, 'm');
+
+   if (test->mode == SENDER && test->sender_has_retransmits)
+   {
+      sender_retrans = stream_retrans;
+   }
+   
+   resault = g_variant_new ("(ddi)",
+                                       unit_atof_ignore_suffix(bw_buff), 
+                                       unit_atof_ignore_suffix(bytes_sent_buf), 
+                                       sender_retrans);
+
+   g_dbus_connection_emit_signal((GDBusConnection *)test->dbusConnection,
+                NULL, //maybe we can specify "bbcd" as the destination
+                IPERF_OBJ_PATH,
+                IPERF_INTERFACE,
+                SIGNAL_IPERF_RESULTS,
+                g_variant_new("(iv)", RESAULT_INTERVAL, resault),
+                &error);
+
+   g_assert_no_error(error);
+   return 0;
+}
+
+
+int
+iperf_send_udp_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent,
+                   iperf_size_t bytes_received,
+                   double jitter,
+                   int lost_packets,
+                   int total_packets,
+                   double lost_percent)
+{
+   char bytes_sent_buf[UNIT_LEN];
+   char bytes_received_buf[UNIT_LEN];
+   char sbw_buff[UNIT_LEN];
+   char cbw_buff[UNIT_LEN];
+   double bandwidth;
+   GError *error = NULL;
+   GVariant *resault = NULL;
+
+   // only send interval result for (1) single stream or (2) sum of the multiple streams
+   if (test->num_streams > 1 && streamID != -1)
+   {
+      return 0;
+   }
+   unit_snprintf(bytes_sent_buf, UNIT_LEN, (double) bytes_sent, 'M');
+	bandwidth = (double) bytes_sent / (double) end_time;
+   unit_snprintf(sbw_buff, UNIT_LEN, bandwidth, 'm');
+
+   unit_snprintf(bytes_received_buf, UNIT_LEN, (double) bytes_received, 'M');
+	bandwidth = (double) bytes_received / (double) end_time;
+   unit_snprintf(cbw_buff, UNIT_LEN, bandwidth, 'm');
+   
+   resault = g_variant_new ("(dddddiid)",
+                                       unit_atof_ignore_suffix(sbw_buff),
+                                       unit_atof_ignore_suffix(cbw_buff), 
+                                       unit_atof_ignore_suffix(bytes_sent_buf),
+                                       unit_atof_ignore_suffix(bytes_received_buf),
+                                       jitter,
+                                       lost_packets,
+                                       total_packets,
+                                       lost_percent);
+
+   g_dbus_connection_emit_signal((GDBusConnection *)test->dbusConnection,
+                NULL, //maybe we can specify "bbcd" as the destination
+                IPERF_OBJ_PATH,
+                IPERF_INTERFACE,
+                SIGNAL_IPERF_RESULTS,
+                g_variant_new("(iv)", RESAULT_END, resault),
+                &error);
+
+   g_assert_no_error(error);
+   return 0;
+}
+
+int
+iperf_send_udp_interval_results_dbus(struct iperf_test *test, 
+                   int streamID, 
+                   double start_time, 
+                   double end_time, 
+                   iperf_size_t bytes_sent, 
+                   float duration,
+                   double jitter,
+                   int lost_packets,
+                   int total_packets,
+                   double lost_percent)
+{
+   char bytes_sent_buf[UNIT_LEN];
+   char bw_buff[UNIT_LEN];
+   double bandwidth;
+   GError *error = NULL;
+   GVariant *resault = NULL;
+
+   // only send interval result for (1) single stream or (2) sum of the multiple streams
+   if (test->num_streams > 1 && streamID != -1)
+   {
+      return 0;
+   }
+   unit_snprintf(bytes_sent_buf, UNIT_LEN, (double) bytes_sent, 'M');
+   if (duration > 0.0) {
+	   bandwidth = (double) bytes_sent / (double) duration;
+   }
+    else 
+   {
+	   bandwidth = 0.0;
+   }
+   unit_snprintf(bw_buff, UNIT_LEN, bandwidth, 'm');
+
+   if (test->mode == SENDER) // when getting interval result, sender would not have lost packets/percent info
+   {
+      resault = g_variant_new ("(ddi)",
+                                          unit_atof_ignore_suffix(bw_buff), 
+                                          unit_atof_ignore_suffix(bytes_sent_buf),
+                                          total_packets);
+   }
+   else
+   {
+      resault = g_variant_new ("(dddiid)",
+                                          unit_atof_ignore_suffix(bw_buff), 
+                                          unit_atof_ignore_suffix(bytes_sent_buf), 
+                                          jitter,
+                                          lost_packets,
+                                          total_packets,
+                                          lost_percent);
+   }
+
+   g_dbus_connection_emit_signal((GDBusConnection *)test->dbusConnection,
+                NULL, //maybe we can specify "bbcd" as the destination
+                IPERF_OBJ_PATH,
+                IPERF_INTERFACE,
+                SIGNAL_IPERF_RESULTS,
+                g_variant_new("(iv)", RESAULT_INTERVAL, resault),
+                &error);
+
+   g_assert_no_error(error);
+   return 0;
+}
+
diff -Naurp iperf-3.8.1_orig/src/iperf_client_api.c iperf-3.8.1_beep/src/iperf_client_api.c
--- iperf-3.8.1_orig/src/iperf_client_api.c	2020-08-13 16:14:38.097981075 +0800
+++ iperf-3.8.1_beep/src/iperf_client_api.c	2020-08-13 16:17:17.544980123 +0800
@@ -465,6 +465,7 @@ iperf_run_client(struct iperf_test * tes
     struct timeval* timeout = NULL;
     struct iperf_stream *sp;
     int rc = -1;
+    DBG(("(%s:%d) Enter =====>\n\n", __func__, __LINE__));
 
     if (test->logfile)
         if (iperf_open_logfile(test) < 0)
@@ -613,5 +614,6 @@ exit:
         iperf_hw_uninit(test);
 #endif
 
+    DBG(("(%s:%d)rc=%d <======Exit\n\n", __func__, __LINE__, rc));
     return rc;
 }
diff -Naurp iperf-3.8.1_orig/src/iperf.h iperf-3.8.1_beep/src/iperf.h
--- iperf-3.8.1_orig/src/iperf.h	2020-08-13 16:14:38.097981075 +0800
+++ iperf-3.8.1_beep/src/iperf.h	2020-08-13 16:17:17.544980123 +0800
@@ -355,6 +355,8 @@ struct iperf_test
     char *server_output_text;
     cJSON *json_server_output;
 
+    void *dbusConnection;
+
     /* Server output (use on server side only) */
     TAILQ_HEAD(iperf_textlisthead, iperf_textline) server_output_list;
 
@@ -393,4 +395,31 @@ struct iperf_test
 
 extern int gerror; /* error value from getaddrinfo(3), for use in internal error handling */
 
+/* !!! comment next line to disable the the Debug prints !!! */
+//#define BCM_DBG
+#ifdef BCM_DBG
+#define DBG(x) printf x
+#else
+#define DBG(x)
+#endif
+#define BCM_UNIQUE_NS          "com.broadcom."
+#define BCM_UNIQUE_NS_PATH     "/com/broadcom/"
+#define IPERF_BUS_NAME BCM_UNIQUE_NS"iperf3"
+#define IPERF_OBJ_PATH BCM_UNIQUE_NS_PATH"iperf3"
+#define IPERF_INTERFACE BCM_UNIQUE_NS"iperf3"
+#define SIGNAL_IPERF_RESULTS  "Iper3fResults"
+
+enum
+{
+   MODE_TCP,
+   MODE_UDP,
+};
+
+enum
+{
+   RESAULT_INTERVAL,
+   RESAULT_END,
+};
+
+
 #endif /* !__IPERF_H */
diff -Naurp iperf-3.8.1_orig/src/iperf_server_api.c iperf-3.8.1_beep/src/iperf_server_api.c
--- iperf-3.8.1_orig/src/iperf_server_api.c	2020-08-13 16:14:38.029981487 +0800
+++ iperf-3.8.1_beep/src/iperf_server_api.c	2020-08-13 16:17:17.544980123 +0800
@@ -400,6 +400,7 @@ iperf_run_server(struct iperf_test *test
     struct iperf_time now;
     struct timeval* timeout;
     int flag;
+    DBG(("(%s:%d) Enter =====>\n\n", __func__, __LINE__));
 
     if (test->logfile)
         if (iperf_open_logfile(test) < 0)
diff -Naurp iperf-3.8.1_orig/src/main.c iperf-3.8.1_beep/src/main.c
--- iperf-3.8.1_orig/src/main.c	2020-08-13 16:14:38.121980929 +0800
+++ iperf-3.8.1_beep/src/main.c	2020-08-13 16:17:17.548980098 +0800
@@ -50,12 +50,51 @@
 #include "units.h"
 
 
+#include <gio/gio.h>
+#include <glib/gprintf.h>
+#include <glib-unix.h>
+#include "beep.h"
+
+#define IPERF_INTERFACE_XML_STRING  "<interface name='"IPERF_INTERFACE"'>"
+
+int _argc;
+char **_argv = NULL;
+guint owner_id = 0;
+int isRunning = 1;
+static int isClientOrServerRunning = 0;
+GMainLoop *main_loop = NULL;
+GDBusConnection *iperf_connection = NULL;
+static GThread *event_thread = NULL;
+static GThread *service_thread = NULL;
+static GMainLoop *event_thread_loop = NULL;
+static GMainLoop *service_thread_loop = NULL;
+static int default_arg_mode = 1;
+
+/* Introspection data for the service we are exporting */
+static const gchar introspection_xml[] =
+"<node>"
+IPERF_INTERFACE_XML_STRING   
+"    <method name='RunWithArgs'>"
+"      <arg direction='in' type='s' name='args'/>"
+"    </method>"
+"    <method name='Stop'>"
+"    </method>"
+"  </interface>"
+"</node>";
+
+static guint registration_id = 0;
+static GDBusNodeInfo   *introspection_data = NULL;
+
+void ServiceStop(void);
+
+
+
 static int run(struct iperf_test *test);
 
 
 /**************************************************************************/
-int
-main(int argc, char **argv)
+//int main(int argc, char **argv)
+static gboolean real_main(void)
 {
     struct iperf_test *test;
 
@@ -98,10 +137,17 @@ main(int argc, char **argv)
         iperf_errexit(NULL, "create new test error - %s", iperf_strerror(i_errno));
     iperf_defaults(test);	/* sets defaults */
 
-    if (iperf_parse_arguments(test, argc, argv) < 0) {
+    test->dbusConnection = iperf_connection;
+
+    /*** ~~~ start iperf3 ***/
+    isClientOrServerRunning = 1;
+
+    
+    if (iperf_parse_arguments(test, _argc, _argv) < 0) {
         iperf_err(test, "parameter error - %s", iperf_strerror(i_errno));
         fprintf(stderr, "\n");
         usage_long(stdout);
+        isRunning = 0;    
         exit(1);
     }
 
@@ -110,6 +156,11 @@ main(int argc, char **argv)
 
     iperf_free_test(test);
 
+    DBG(("\n~~~real_main isRunning %d, isClientOrServerRunning %d\n\n", isRunning,isClientOrServerRunning ));
+    isRunning = 0;
+
+    //~~~ g_main_loop_quit (service_thread_loop);
+
     return 0;
 }
 
@@ -151,6 +202,7 @@ run(struct iperf_test *test)
             for (;;) {
 		int rc;
 		rc = iperf_run_server(test);
+      DBG(("(%s:%d) return from iperf_run_server(), rc=%d =====>\n\n", __func__, __LINE__, rc));
 		if (rc < 0) {
 		    if (rc < -1) {
                         goto error;
@@ -168,6 +220,7 @@ run(struct iperf_test *test)
 		}
             }
 	    iperf_delete_pidfile(test);
+       DBG(("(%s:%d) exited for loop =====>\n\n", __func__, __LINE__));
             break;
 	case 'c':
 	    if (iperf_run_client(test) < 0)
@@ -189,5 +242,445 @@ error:
         iperf_hw_uninit(test);
 #endif
     iperf_errexit(test, "error - %s", iperf_strerror(i_errno));
+
+    DBG(("\n~~~real_main isRunning %d, isClientOrServerRunning %d\n\n", isRunning,isClientOrServerRunning ));
+
+    isRunning = 0;
+
     return -1;
 }
+
+
+
+
+void ServiceStop(void) {
+#ifdef HAVE_THREAD
+    Sig_Interupt( 1 );
+#else
+   exit(1);//~~~ sig_exit(1);
+#endif
+}
+
+static void iperf_signal_handler (GDBusConnection  *connection __attribute__((unused)),
+        const gchar      *sender_name __attribute__((unused)),
+        const gchar      *object_path __attribute__((unused)),
+        const gchar      *interface_name __attribute__((unused)),
+        const gchar      *signal_name,
+        GVariant         *parameters __attribute__((unused)),
+        gpointer         user_data __attribute__((unused)))
+{
+    g_print("========>iperf received signal %s from sender %s\n", signal_name, sender_name);
+  //~~~  if (strcmp(signal_name, SIGNAL_PMD_TERMINATION) == 0)
+    if (strcmp(signal_name, SIGNAL_PMD_TERMINATION) == 0)
+    {
+        if(isClientOrServerRunning)
+        {
+            ServiceStop();
+        }
+        isRunning = 0;
+    }
+}
+
+static int createArgv(char *inputStr, char ***argv)
+{
+    int ret = 0;
+    int new_argc = 0;
+    char **new_argv;
+    char *ptr;
+    int count = 0;
+    char *inputStr_backup = NULL;
+
+    DBG(("\n~~~createArgv  inputStr %s\n", inputStr));
+    
+    if(!inputStr)
+        return ret;
+
+    inputStr_backup = (char*)malloc(strlen(inputStr)+1);
+    strcpy(inputStr_backup, inputStr);
+
+    /* the first while loop to caculate the number of args */
+    ptr = strtok (inputStr," ");
+    while (ptr != NULL)
+    {
+        new_argc++;
+        ptr = strtok (NULL, " ");
+    }
+
+    if(new_argc == 0)
+        goto out;
+
+    new_argv = (char**)malloc(sizeof(char*) * (new_argc));
+
+    /* the second while loop to allocate buffer and copy */
+    ptr = strtok (inputStr_backup," ");
+    while (ptr != NULL && count < new_argc)
+    {
+        new_argv[count] = (char*)malloc(strlen(ptr)+1);
+        strcpy(new_argv[count], ptr);
+        ptr = strtok (NULL, " ");
+        count++;
+    }
+
+    *argv = new_argv;
+    ret = count;
+
+out:
+    if(inputStr_backup != NULL)
+        free(inputStr_backup);
+    return ret;
+}
+
+static void freeArgv(void)
+{
+    int argc = 0;
+    int i;
+
+    if (_argv != NULL)
+    {
+        for(i=0; i < _argc; i++)
+        {
+            if(_argv[i] != NULL)
+            {
+                free(_argv[i]);
+                argc++;
+            }
+        }
+        free(_argv);
+        _argv = NULL;
+    }
+    _argc = 0;
+}
+
+gpointer iperf_event_thread(gpointer user_data __attribute__((unused)))
+{
+    GMainContext *thread_context = NULL;
+
+    /* Create the GMainContext structure for this thread */
+    thread_context = g_main_context_new ();
+
+    /* subscribe interested signals */
+    g_dbus_connection_signal_subscribe (iperf_connection,
+    											PMD_BUS_NAME,
+    											PMD_INTERFACE,
+    											SIGNAL_PMD_TERMINATION,
+    											PMD_OBJECT_PATH,
+    											NULL,
+    											G_DBUS_SIGNAL_FLAGS_NONE,
+    											iperf_signal_handler,
+    											NULL,
+    											NULL);
+    /* Create the thread GMainLoop structure */
+    event_thread_loop = g_main_loop_new (thread_context, FALSE);
+
+    /* Run notify loop and process its events */
+    g_main_loop_run (event_thread_loop);
+
+    /* Unref thread loop after loop exits
+      it might be caused by g_main_loop_quit */
+    if (event_thread_loop)
+    {
+        g_main_loop_unref (event_thread_loop);
+        event_thread_loop = NULL;
+    }
+
+    /* Unref the thread context */
+    g_main_context_unref (thread_context);
+
+    g_thread_exit (NULL);
+    return NULL;
+}
+
+/** service thread: Create a loop to perform iperf service */
+static gpointer iperf_service_thread(gpointer user_data __attribute__((unused)))
+{
+    GMainContext *thread_context = NULL;
+    GSource      *service_thread_source  = NULL;
+
+    /* Create the GMainContext structure for this thread */
+    thread_context = g_main_context_new ();
+
+    /* Create a new service_thread_source and configure its properties */
+    service_thread_source = g_timeout_source_new (500);
+    g_source_set_name (service_thread_source, "service thread Timeout");
+    g_source_set_callback (service_thread_source, (GSourceFunc)real_main, NULL, NULL);
+    g_source_set_priority (service_thread_source, G_PRIORITY_HIGH);
+
+    /* Attach source to the context */
+    g_source_attach (service_thread_source, thread_context);
+    g_source_unref (service_thread_source);
+
+    /* Create the thread GMainLoop structure */
+    service_thread_loop = g_main_loop_new (thread_context, FALSE);
+
+    /* Run main loop */
+    g_main_loop_run(service_thread_loop);
+
+    /* Unref GMainLoop structure after escaping main loop */
+    if (service_thread_loop)
+    {
+        g_main_loop_unref (service_thread_loop);
+        service_thread_loop = NULL;
+    }
+
+    /* Unref the thread context */
+    g_main_context_unref (thread_context);
+
+    if(!default_arg_mode)
+        freeArgv();
+
+    g_thread_exit(NULL);
+    return NULL;
+} 
+
+static void
+process_method_call (GDBusConnection       *connection  __attribute__((unused)),
+        const gchar           *sender,
+        const gchar           *object_path __attribute__((unused)),
+        const gchar           *interface_name __attribute__((unused)),
+        const gchar           *method_name,
+        GVariant              *parameters,
+        GDBusMethodInvocation *invocation,
+        gpointer               user_data __attribute__((unused)))
+{
+    char *input_args = NULL;
+    GError *error = NULL;
+
+    if(strcmp(method_name, "RunWithArgs") == 0)
+    {
+        if(isClientOrServerRunning)
+            return;
+
+        /* retrieve parameter */
+        g_variant_get (parameters, "(s)", &input_args);
+
+
+        freeArgv();
+      
+        _argc = createArgv(input_args, &_argv);
+
+        if(_argv != NULL && _argc > 0)
+        {
+            service_thread = g_thread_try_new ("service_thread", iperf_service_thread, NULL, &error);
+        }
+        default_arg_mode = 0;
+        g_assert_no_error (error);
+    }
+    else if(strcmp(method_name, "Stop") == 0)
+    {
+        ServiceStop();
+    }
+    
+    if (input_args != NULL)
+        g_free (input_args);
+    g_dbus_method_invocation_return_value (invocation, g_variant_new("()"));
+}
+
+static const GDBusInterfaceVTable interface_vtable =
+{
+    process_method_call, NULL, NULL, { NULL}
+};
+
+static void
+on_bus_acquired (GDBusConnection *connection,
+        const gchar     *name  __attribute__((unused)),
+        gpointer         user_data  __attribute__((unused)))
+{
+    GError *error = NULL;
+
+    /* Save connection */
+    iperf_connection = connection;
+
+    registration_id = g_dbus_connection_register_object(connection,
+            IPERF_OBJ_PATH,
+            introspection_data->interfaces[0],
+            &interface_vtable,
+            NULL,  /* user_data */
+            NULL,  /* user_data_free_func */
+            NULL); /* GError** */
+    g_assert (registration_id > 0);
+
+    /* Create the notify thread to handle event notification. */
+    event_thread = g_thread_try_new ("event_thread", iperf_event_thread,
+                                     NULL, &error);
+    g_assert_no_error (error);
+}
+
+
+static void
+on_name_acquired (GDBusConnection *connection  __attribute__((unused)),
+        const gchar     *name,
+        gpointer         user_data  __attribute__((unused)))
+{
+    DBG(("\nAcquired the name %s\n\n", name));
+}
+
+
+static void
+on_name_lost (GDBusConnection *connection __attribute__((unused)),
+        const gchar     *name,
+        gpointer         user_data  __attribute__((unused)))
+{
+    DBG(("\nLost the name %s\n\n", name));
+    exit(1);
+}
+
+static gboolean sigterm_handler(gpointer user_data __attribute__((unused)))
+{
+    g_print ("iperf received SIGTERM. Terminating....\n");
+    if(isClientOrServerRunning)
+    {
+        ServiceStop();
+    }
+    isRunning = 0;
+
+    return TRUE;
+}
+
+// check isRunning 
+static gboolean iperf_loop(gpointer user_data __attribute__((unused)))
+{
+    if (!isRunning)
+    {
+        DBG(("\n~~~iperf_loop: isRunning=%d, isClientOrServerRunning=%d\n\n", isRunning,isClientOrServerRunning ));
+        /* quit the main loop */
+        g_main_loop_quit (main_loop);
+    }
+    
+    return isRunning;
+}
+
+static int iperf_stack(void)
+{
+    GSource *iperf_source = NULL;
+    GSource *sigterm_source = NULL;
+
+    /* Parse introspection_xml and returns
+        * a GDBusNodeInfo that can be used to
+        * lookup interface information.
+        * Note that this routine is using a
+        * GMarkup-based parser that only accepts
+        * a subset of valid XML documents */
+    introspection_data = g_dbus_node_info_new_for_xml (introspection_xml, NULL);
+	
+    g_assert(introspection_data != NULL);
+
+    /* Acquire "com.broadcom.iperf" on the G_BUS_TYPE_SYSTEM,
+         * and calls on_name_acquired and on_name_lost when
+         * the name is acquired respectively lost.
+         * Callbacks will be invoked in the thread-default main
+         * context of the thread you are calling this function from */
+    owner_id = g_bus_own_name (G_BUS_TYPE_SYSTEM,
+            IPERF_BUS_NAME,
+            G_BUS_NAME_OWNER_FLAGS_NONE,
+            on_bus_acquired,
+            on_name_acquired,
+            on_name_lost,
+            NULL,
+            NULL);
+
+    iperf_source = g_timeout_source_new(100);
+    g_source_set_name (iperf_source, "main loop");
+    g_source_set_callback(iperf_source, (GSourceFunc)iperf_loop,
+            NULL, NULL);
+
+    /* Attach iperf source to the default context */
+    g_source_attach (iperf_source, NULL);
+
+    /* Unref the iperf source */
+    g_source_unref (iperf_source);
+
+    /* Create a new GMainLoop structure */
+    main_loop = g_main_loop_new (NULL, FALSE);
+
+    /* Create sigterm source and configure its properties */
+    sigterm_source = g_unix_signal_source_new (SIGTERM);
+    g_source_set_name (sigterm_source, "SIGTERM handling");
+    g_source_set_callback (sigterm_source, (GSourceFunc)sigterm_handler, NULL, NULL);
+    g_source_set_priority (sigterm_source, G_PRIORITY_HIGH);
+
+    /* Attach sigterm source to the default context */
+    g_source_attach (sigterm_source, NULL);
+
+    /* Unref the sigterm source */
+    g_source_unref (sigterm_source);
+
+    /* Runs a main loop and perform actions */
+    g_main_loop_run (main_loop);
+
+    /* Quit the event thread loop before exit */
+    if (event_thread_loop)
+    {
+        g_main_loop_quit (event_thread_loop);
+        g_thread_join (event_thread);
+        event_thread_loop = NULL;
+    }
+
+    /* Quit the service thread loop before exit */
+    if (service_thread_loop)
+    {
+        g_main_loop_quit (service_thread_loop);
+        g_thread_join (service_thread);
+        service_thread_loop = NULL;
+    }
+
+    /* Decrease the reference count on a GMainLoop
+       * object by one. If the result is zero,
+       * free the loop and free all associated memory */
+    g_main_loop_unref (main_loop);
+
+    /* Unref event thread */
+    if (event_thread)
+    {
+        g_thread_unref (event_thread);
+        event_thread = NULL;
+    }
+
+    /* Unref service thread */
+    if (service_thread)
+    {
+        g_thread_unref (service_thread);
+        service_thread = NULL;
+    }
+
+    return 0;
+}
+
+static int iperf_init(void)
+{
+    DBG(("#### [%s:%d] ####\n", __func__, __LINE__));
+    /* Ignore broken pipes */
+    signal(SIGPIPE, SIG_IGN);
+    return 0;
+}
+
+static void iperf_exit(void)
+{
+    DBG(("#### [%s:%d] ####\n", __func__, __LINE__));
+
+    /* Stop owning a name */
+    g_bus_unown_name (owner_id);
+}
+
+int main(int argc, char **argv)
+{
+    int rv = 0;
+
+    rv = iperf_init();
+
+    if (!rv)
+    {
+        /* iperf main loop */
+        rv = iperf_stack();
+    }
+
+    /* clean allocated resources */
+    iperf_exit();
+
+    return rv;
+}
+
+
+
+
+
+
